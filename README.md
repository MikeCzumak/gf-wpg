# gf-wpg

A wordlist-based pattern generator to use with gf (by tomnomnom)

## Overview

I use tomnomnom's [gf](https://github.com/tomnomnom/gf) quite a lot. Some patterns (like AWS keys) are fairly static and don't change much once they're created. However, there are some patterns that I use extensively with wordlists. For example, when grepping for keywords in URLs I have separate lists for SSRF, SQLi, etc. I regularly update those wordlists (and often customize them depending on the testing target) so I don't want to manually have to create or update separate gf pattern files each time. 

This python script does that work for me, reading in a wordlist and quickly creating a corresponding gf pattern file.  

## Usage

```
usage: gf-wpg.py [-h] -t {query_param,body_param,path,ext} -w WORDLIST -n NAME [-a] [-f FLAGS]

Generate .json pattern file for gf

optional arguments:
  -h, --help            show this help message and exit


  -t {query_param,body_param,path,ext}, --type {query_param,body_param,path,ext}

	Type of regex to generate.
	 query_param: Find query parameter names in the URL
	 body_param: Find query parameter names in the html body
	 path: Find keywords in a URL path
	 ext: Filter on extensions (e.g. .jpeg)


  -w WORDLIST, --wordlist WORDLIST
                        Path to the wordlist to use for regex generation


  -n NAME, --name NAME  Name of the pattern (used to name the json file


  -a, --audit           Generate 'looser' audit regex to find additional matches (higher false positives). Default = False.


  -f FLAGS, --flags FLAGS

	Omit dashes (E is included by default)
	 H: Print filename
	 n: Print line #
	 o: Only match
	 v: Invert
	 i: Ignore case
	 r: Recursive
	 a: Binary as text


	(see Grep man for more flag options)
```

This is a really basic script but there are a few options to be aware of.

**type**

I've included four different options for the pattern `type` (`-t`) based on what I use the most. The two "param" options (`query_param` and `body_param`) are what I use to grep for wordlist values in the respective parameter names. So, if you have a wordlist that includes a value of `user_id`, the `query_param` regex will grep for `?user_id=` and `&user_id=` (to be used if you're parsing URLs). Similarly, the `body_param` regex will grep for `name="user_id"` (to be used if you're parsing html). The `path` option will grep for `/path/` (also for URLs). I use `ext` option to grep for lists of file extensions (.jpg, .php, etc.), primarily when filtering in/out specific URLs. 

**wordlist**

The wordlist argument is self-explanatory -- just a path to a simple, line-delimited list of words.

**name**

The `name` argument provides the name of the pattern file to use with gf. It will automatically be written to the .gf folder (obviously you must have gf installed, see dependencies). The script leverages `os.path.expanduser('~/.gf')` to find the write directory -- caution I've only tested on Mac OS to-date. 

**flags** 

These are just normal grep flags. I have already included E (Extended) as a default since that is how the regex is written. Other valid grep options can be added as needed. I include a few common ones in the help just for reference. 

**audit**

By default, the `audit` argument is set to False but explicitly passing it at run time sets it to True. What this does is select a 'looser' regex for each of the pattern types described above to allow for broader matching. 

For example, in the default mode, the regex for `query_param` looks like this: `[?&]{1}%s[=]` which only allows for strict matching of the words in the provided wordlist. So a word `user_id` will only match on `?user_id=` or `&user_id=`. When sorting through a large number of URLs I often prefer this preciseness to eliminate false positive matches, which is why I regularly curate my wordlists. However, this strict match would miss a parameter value of `admin_user_id` so you then risk false negatives (i.e. missing something interesting). 

The 'looser' regex for `query_param` which is enabled with the `-a` option looks like this `[?&]{1}[0-9a-zA-Z_-]*%s[0-9a-zA-Z_-]*[=]{1}`. It still follows the general format of `?word=` or `&word=` but allows for characters to occur on either side of the provided word. This will ensure you catch parameters that don't just strictly match what's on your wordlist but will also lead to higher false positives. 

**Using the `audit` option to curate wordlists**

What I will often do is curate my wordlist (to tailor it to a target) using <u>both</u> an 'audit' and a default 'strict' gf pattern generated by this script. To do so, I use the same wordlist but create two gf patterns -- One with `-a` and the other without it but with a `v` grep flag added (for inverse matching). 

`python3 gf-wpg.py -t query_param -w /path/to/wordlist.file -n auditpattern -a -v io`
<br>
`python3 gf-wpg.py -t query_param -w /path/to/wordlist.file -n strictpattern -v iov`

I then run my target list of URLs through gf twice like this:

`cat wordlist | gf auditpattern | gf strictpattern | vim -`

What you should then see are any matches against the looser audit grep pattern that don't already strictly match your wordlist. This does a good job of showing you what you're missing with strict regex. I use this output to determine which if any of the looser audit matches I might want to add to my wordlist. This way I'm not only developing custom wordlists for a given target but I'm also continuously improving my wordlists for future targets. 

You could of course also  use the auditpatern and then do a file diff of the output with your wordlist but I prefer this method because it's quick and easy. 

## Dependencies
You should just need [gf](https://github.com/tomnomnom/gf) and python (3). I will caution that I've only tested on Mac OS to-date so I can't guarantee behavior / portability on other OSs at the moment.

## License 

LICENSE/WARRANTY: This code is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or(at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
